import { Group, Site, LoginResponse, ExportData, ImportResult, GroupWithSites } from './http';
import { mockGroups as importedMockGroups, mockSites as importedMockSites, mockConfigs as importedMockConfigs } from './mockData';

// 本地存储键名
const STORAGE_KEYS = {
  GROUPS: 'mock_groups',
  SITES: 'mock_sites',
  CONFIGS: 'mock_configs',
};

// 从localStorage加载数据，如果不存在则使用导入的mock数据
function loadFromStorage<T>(key: string, defaultValue: T): T {
  if (typeof localStorage !== 'undefined') {
    const stored = localStorage.getItem(key);
    if (stored) {
      try {
        return JSON.parse(stored);
      } catch (e) {
        console.warn(`解析localStorage数据失败: ${key}`, e);
      }
    }
  }
  return defaultValue;
}

// 保存数据到localStorage
function saveToStorage<T>(key: string, data: T): void {
  if (typeof localStorage !== 'undefined') {
    try {
      localStorage.setItem(key, JSON.stringify(data));
    } catch (e) {
      console.warn(`保存localStorage数据失败: ${key}`, e);
    }
  }
}

// 使用localStorage持久化的mock数据
const mockGroups: Group[] = loadFromStorage(STORAGE_KEYS.GROUPS, [...importedMockGroups]);
const mockSites: Site[] = loadFromStorage(STORAGE_KEYS.SITES, [...importedMockSites]);
const mockConfigs: Record<string, string> = loadFromStorage(STORAGE_KEYS.CONFIGS, { ...importedMockConfigs });

// 保存当前状态的辅助函数
function saveGroupsToStorage(): void {
  saveToStorage(STORAGE_KEYS.GROUPS, mockGroups);
}

function saveSitesToStorage(): void {
  saveToStorage(STORAGE_KEYS.SITES, mockSites);
}

function saveConfigsToStorage(): void {
  saveToStorage(STORAGE_KEYS.CONFIGS, mockConfigs);
}

// 模拟API实现
export class MockNavigationClient {
  private token: string | null = null;
  public isAuthenticated: boolean = false; // 公开认证状态

  constructor() {
    // 从本地存储加载令牌
    if (typeof localStorage !== 'undefined') {
      this.token = localStorage.getItem('auth_token');
      this.isAuthenticated = !!this.token;
    }
  }

  // 检查是否已登录
  isLoggedIn(): boolean {
    return !!this.token;
  }

  // 设置认证令牌
  setToken(token: string): void {
    this.token = token;
    this.isAuthenticated = true;
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('auth_token', token);
    }
  }

  // 清除认证令牌
  clearToken(): void {
    this.token = null;
    this.isAuthenticated = false;
    if (typeof localStorage !== 'undefined') {
      localStorage.removeItem('auth_token');
    }
  }

  // 登录API
  async login(
    username: string,
    password: string,
    rememberMe: boolean = false
  ): Promise<LoginResponse> {
    await new Promise((resolve) => setTimeout(resolve, 500));
    console.log(username, password, rememberMe ? '记住登录' : '标准登录');
    // 模拟登录验证逻辑 - 在Mock环境中任何账号密码都能登录
    const token = btoa(`${username}:${new Date().getTime()}:${rememberMe}`);
    this.setToken(token);

    return {
      success: true,
      token: token,
      message: `登录成功(模拟环境)${rememberMe ? '，已记住登录状态' : ''}`,
    };
  }

  // 登出
  logout(): void {
    this.clearToken();
  }

  // 检查身份验证状态
  async checkAuthStatus(): Promise<boolean> {
    await new Promise((resolve) => setTimeout(resolve, 300));

    // 模拟真实环境中的行为：如果有token则认为已认证
    if (this.token) {
      return true;
    }

    // 开发环境中，也可以设置为总是返回true，便于开发
    // return true;

    // 没有token则需要登录
    return false;
  }

  async getGroups(): Promise<Group[]> {
    // 模拟网络延迟
    await new Promise((resolve) => setTimeout(resolve, 200));

    // 根据认证状态过滤分组
    if (!this.isAuthenticated) {
      return mockGroups.filter((g) => g.is_public === 1);
    }
    return [...mockGroups];
  }

  // 获取所有分组及其站点 (使用 JOIN 优化,避免 N+1 查询)
  async getGroupsWithSites(): Promise<GroupWithSites[]> {
    await new Promise((resolve) => setTimeout(resolve, 200));

    let groups = [...mockGroups];
    let sites = [...mockSites];

    // 根据认证状态过滤
    if (!this.isAuthenticated) {
      // 访客只能看到公开分组下的公开站点
      groups = groups.filter((g) => g.is_public === 1);
      const publicGroupIds = groups.map((g) => g.id!);
      sites = sites.filter(
        (site) => site.is_public === 1 && publicGroupIds.includes(site.group_id)
      );
    }

    // 组合分组和站点
    return groups.map((group) => ({
      ...group,
      id: group.id!, // 确保 id 存在
      sites: sites.filter((site) => site.group_id === group.id),
    }));
  }

  async getGroup(id: number): Promise<Group | null> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    return mockGroups.find((g) => g.id === id) || null;
  }

  async createGroup(group: Group): Promise<Group> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const newGroup = {
      ...group,
      id: Math.max(0, ...mockGroups.map((g) => g.id || 0)) + 1,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    mockGroups.push(newGroup);
    saveGroupsToStorage();
    return newGroup;
  }

  async updateGroup(id: number, group: Partial<Group>): Promise<Group | null> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const index = mockGroups.findIndex((g) => g.id === id);
    if (index === -1) return null;

    const existing = mockGroups[index];
    if (!existing) return null;

    mockGroups[index] = {
      ...existing,
      ...group,
      updated_at: new Date().toISOString(),
    };
    const updated = mockGroups[index];
    saveGroupsToStorage();
    return updated || null;
  }

  async deleteGroup(id: number): Promise<boolean> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const index = mockGroups.findIndex((g) => g.id === id);
    if (index === -1) return false;

    mockGroups.splice(index, 1);
    saveGroupsToStorage();
    return true;
  }

  async getSites(groupId?: number): Promise<Site[]> {
    await new Promise((resolve) => setTimeout(resolve, 200));

    let sites = [...mockSites];

    // 根据认证状态过滤站点
    if (!this.isAuthenticated) {
      // 访客只能看到公开分组下的公开站点
      const publicGroupIds = mockGroups.filter((g) => g.is_public === 1).map((g) => g.id);

      sites = sites.filter(
        (site) => site.is_public === 1 && publicGroupIds.includes(site.group_id)
      );
    }

    // 按分组过滤
    if (groupId) {
      return sites.filter((site) => site.group_id === groupId);
    }

    return sites;
  }

  // 实现其他方法，与NavigationClient保持一致的接口...
  async getSite(id: number): Promise<Site | null> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    return mockSites.find((s) => s.id === id) || null;
  }

  async createSite(site: Site): Promise<Site> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const newSite = {
      ...site,
      id: Math.max(0, ...mockSites.map((s) => s.id || 0)) + 1,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    };
    mockSites.push(newSite);
    saveSitesToStorage();
    return newSite;
  }

  async updateSite(id: number, site: Partial<Site>): Promise<Site | null> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const index = mockSites.findIndex((s) => s.id === id);
    if (index === -1) return null;

    const existing = mockSites[index];
    if (!existing) return null;

    mockSites[index] = {
      ...existing,
      ...site,
      updated_at: new Date().toISOString(),
    };
    const updated = mockSites[index];
    saveSitesToStorage();
    return updated || null;
  }

  async deleteSite(id: number): Promise<boolean> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    const index = mockSites.findIndex((s) => s.id === id);
    if (index === -1) return false;

    mockSites.splice(index, 1);
    saveSitesToStorage();
    return true;
  }

  async updateGroupOrder(groupOrders: { id: number; order_num: number }[]): Promise<boolean> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    for (const order of groupOrders) {
      const index = mockGroups.findIndex((g) => g.id === order.id);
      if (index !== -1) {
        const group = mockGroups[index];
        if (group) {
          group.order_num = order.order_num;
        }
      }
    }
    saveGroupsToStorage();
    return true;
  }

  async updateSiteOrder(siteOrders: { id: number; order_num: number }[]): Promise<boolean> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    for (const order of siteOrders) {
      const index = mockSites.findIndex((s) => s.id === order.id);
      if (index !== -1) {
        const site = mockSites[index];
        if (site) {
          site.order_num = order.order_num;
        }
      }
    }
    saveSitesToStorage();
    return true;
  }

  // 配置相关API
  async getConfigs(): Promise<Record<string, string>> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    return { ...mockConfigs };
  }

  async getConfig(key: string): Promise<string | null> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    return mockConfigs[key] || null;
  }

  async setConfig(key: string, value: string): Promise<boolean> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    mockConfigs[key] = value;
    saveConfigsToStorage();
    return true;
  }

  async deleteConfig(key: string): Promise<boolean> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    if (key in mockConfigs) {
      delete mockConfigs[key];
      saveConfigsToStorage();
      return true;
    }
    return false;
  }

  // 数据导出
  async exportData(): Promise<ExportData> {
    await new Promise((resolve) => setTimeout(resolve, 200));
    return {
      groups: [...mockGroups],
      sites: [...mockSites],
      configs: { ...mockConfigs },
      version: '1.0',
      exportDate: new Date().toISOString(),
    };
  }

  // 数据导入
  async importData(data: ExportData): Promise<ImportResult> {
    await new Promise((resolve) => setTimeout(resolve, 500));

    try {
      // 统计信息
      const stats = {
        groups: {
          total: data.groups.length,
          created: 0,
          merged: 0,
        },
        sites: {
          total: data.sites.length,
          created: 0,
          updated: 0,
          skipped: 0,
        },
      };

      // 模拟合并处理
      // 为分组创建映射 - 旧ID到新ID
      const groupMap = new Map<number, number>();

      // 处理分组
      for (const importGroup of data.groups) {
        // 检查是否存在同名分组
        const existingGroupIndex = mockGroups.findIndex((g) => g.name === importGroup.name);

        if (existingGroupIndex >= 0) {
          // 已存在同名分组，添加到映射
          const existingGroup = mockGroups[existingGroupIndex];
          if (importGroup.id && existingGroup && existingGroup.id) {
            groupMap.set(importGroup.id, existingGroup.id);
          }
          stats.groups.merged++;
        } else {
          // 创建新分组
          const newId = Math.max(0, ...mockGroups.map((g) => g.id || 0)) + 1;
          const newGroup = {
            ...importGroup,
            id: newId,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };

          mockGroups.push(newGroup);

          // 添加到映射
          if (importGroup.id) {
            groupMap.set(importGroup.id, newId);
          }
          stats.groups.created++;
        }
      }

      // 处理站点
      for (const importSite of data.sites) {
        // 获取新分组ID
        const newGroupId = groupMap.get(importSite.group_id);

        // 如果没有映射的分组ID，跳过该站点
        if (!newGroupId) {
          stats.sites.skipped++;
          continue;
        }

        // 检查是否有相同URL的站点在同一分组下
        const existingSiteIndex = mockSites.findIndex(
          (s) => s.group_id === newGroupId && s.url === importSite.url
        );

        if (existingSiteIndex >= 0) {
          // 更新现有站点
          const existingSite = mockSites[existingSiteIndex];
          if (existingSite) {
            mockSites[existingSiteIndex] = {
              ...existingSite,
              name: importSite.name,
              icon: importSite.icon,
              description: importSite.description,
              notes: importSite.notes,
              updated_at: new Date().toISOString(),
            };
            stats.sites.updated++;
          }
        } else {
          // 创建新站点
          const newId = Math.max(0, ...mockSites.map((s) => s.id || 0)) + 1;
          const newSite = {
            ...importSite,
            id: newId,
            group_id: newGroupId, // 使用新的分组ID
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString(),
          };

          mockSites.push(newSite);
          stats.sites.created++;
        }
      }

      // 导入配置数据
      Object.entries(data.configs).forEach(([key, value]) => {
        mockConfigs[key] = value;
      });

      // 保存所有数据
      saveGroupsToStorage();
      saveSitesToStorage();
      saveConfigsToStorage();

      return {
        success: true,
        stats,
      };
    } catch (error) {
      console.error('模拟导入数据失败:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : '未知错误',
      };
    }
  }
}
